# -*- coding: utf-8 -*-
"""DSA - Wolfsburg SARIMA FIX.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KuiF_5yBSPXvhx0hzD6zPy3oiIGw_obx
"""

pip install matplotlib

pip install seaborn

pip install pandas

pip install numpy

"""Cleansing"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from google.colab import drive
drive.mount('/content/drive')

wolfsburg = pd.read_csv('/content/drive/MyDrive/DSA/wolfsburg.csv')

df = wolfsburg
df.head()

df.shape

# ====== 1. Import libraries ======
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_squared_error, mean_absolute_error
import warnings
warnings.filterwarnings("ignore")

# ====== 2. Load data ======
df = wolfsburg

# Quick info (optional)
print(df.shape)
print(df.dtypes)
print(df[['day','interval','detid','flow','occ','error','city']].head())

print(df.head())

# -------------------------------------------------------------------
# 2. CEK DATA YANG RUSAK
# -------------------------------------------------------------------

# 1. Cek data hilang
print("--- Pengecekan Data Hilang (NaN) ---")
print(df.isnull().sum())
print("\n")

# 2. Cek tipe data
print("--- Pengecekan Tipe Data (info) ---")
df.info()
print("\n")

# 3. Cek duplikat
print("--- Pengecekan Data Duplikat ---")
print(f"Jumlah baris duplikat: {df.duplicated().sum()}")
print("\n")

# 4. Cek statistik kolom angka (untuk outliers)
print("--- Pengecekan Statistik Angka (Describe) ---")
print(df.describe())
print("\n")

# 5. Cek konsistensi kolom kategori (ganti 'nama_kolom_kategori' dengan kolom Anda)
# Misalnya: print(df['kota'].value_counts())

print(df.count())

# -------------------------------------------------------------------
# CEK JUMLAH TANGGAL (BIAR GA KAYAK VADRID)
# -------------------------------------------------------------------

# Menghitung data unik, lalu mengurutkannya berdasarkan index (yaitu tanggal)
print(df['day'].value_counts().sort_index())

# -------------------------------------------------------------------
# 3. CEK JUMLAH BARIS YANG RUSAK (ERROR = 1; OCC = 0; FLOW < 0)
# -------------------------------------------------------------------


jumlah_baris = ((df['error'] == 1) | (df['occ'] == 0) | (df['flow'] < 0)).sum()
print(jumlah_baris)

# -------------------------------------------------------------------
# 4. FIX KOLOM ERROR DAN FLOW LALU HAPUS KEDUANYA (DATA YANG GA PERLU)
# -------------------------------------------------------------------

# --- 1. Menghapus Baris Error (error == 1) ---
# Kita ingin mempertahankan baris yang error-nya BUKAN 1
# (Termasuk yang NaN atau 0)
jumlah_error_1 = (df['error'] == 1).sum()
print(f"Menghapus {jumlah_error_1} baris dengan error == 1...")
df = df[df['error'] != 1].copy()


# --- 2. Menghapus Baris Arus Tidak Logis (flow < 1) ---
# Filter ini juga akan otomatis menghapus baris yang flow-nya NaN
jumlah_flow_kecil = (df['flow'] < 1).sum()
print(f"Menghapus {jumlah_flow_kecil} baris dengan flow < 1...")
df = df[df['flow'] >= 1].copy()


# --- 3. Membuang Kolom 'error' ---
# Karena sudah tidak relevan, kita buang kolomnya
print("Membuang kolom 'error'...")
if 'error' in df.columns:
    df = df.drop(columns=['error'])
else:
    print("Kolom 'error' sudah tidak ada.")


# --- 4. Menghapus Sisa Baris NaN (Pembersih Akhir) ---
# Menghapus baris yang mungkin masih punya NaN di kolom penting
# (Ini akan menghapus baris 2575039 yang Anda temukan sebelumnya)
print(f"Jumlah baris sebelum pembersihan NaN akhir: {len(df)}")
df = df.dropna(subset=['interval', 'detid', 'flow', 'occ'])
print(f"Jumlah baris setelah pembersihan NaN akhir: {len(df)}")

"""SARIMA"""

# Gabungkan tanggal & waktu
df['timestamp'] = pd.to_datetime(df['day']) + pd.to_timedelta(df['interval'], unit='s')

# Filter Sensor Terbaik
target_detector = df['detid'].value_counts().idxmax()
print(f"Menggunakan Sensor: {target_detector}")
df = df[df['detid'] == target_detector].copy()

# Set Index
df.set_index('timestamp', inplace=True)
df.sort_index(inplace=True)

# 2. RESAMPLING & FITUR TAMBAHAN
# Ubah ke per Jam (Hourly)
ts_hourly = df['flow'].resample('H').mean().interpolate(method='linear')

# --- TRIK KHUSUS: DETEKSI WEEKEND ---
# Kita buat data bantuan (Exogenous) untuk memberitahu model mana Sabtu/Minggu
# 0 = Hari Kerja, 1 = Akhir Pekan (Sabtu/Minggu)
exog_data = pd.DataFrame(index=ts_hourly.index)
exog_data['is_weekend'] = (exog_data.index.dayofweek >= 5).astype(int)

# 3. PEMBAGIAN DATA (TRAIN vs TEST)
# Kita ambil 3 hari terakhir untuk tes, sisanya untuk training
test_days = 3
test_steps = test_days * 24

# Data Training (Mulai tanggal 19 sampai sebelum 3 hari terakhir)
train_data = ts_hourly[:-test_steps]
train_exog = exog_data[:-test_steps]

# Data Test (3 Hari Terakhir)
test_data = ts_hourly[-test_steps:]
test_exog = exog_data[-test_steps:]

print(f"Data Training Mulai : {train_data.index.min()}")
print(f"Data Training Selesai: {train_data.index.max()}")
print(f"Jumlah Jam Training : {len(train_data)} jam")

# 4. TRAINING MODEL SARIMA (DENGAN FITUR WEEKEND)
print("\nSedang melatih model (tunggu sebentar)...")
# Order=(1,0,1) dan Seasonal=(1,1,1,24) adalah kombinasi umum yang stabil
model = SARIMAX(train_data,
                exog=train_exog,  # Masukkan fitur weekend di sini
                order=(1, 0, 1),
                seasonal_order=(1, 1, 1, 24),
                enforce_stationarity=False,
                enforce_invertibility=False)

model_fit = model.fit(disp=False)

# 5. PREDIKSI
# Kita butuh data exog (info weekend) untuk masa depan agar prediksi akurat
forecast = model_fit.get_forecast(steps=len(test_data), exog=test_exog)
predicted_mean = forecast.predicted_mean
conf_int = forecast.conf_int()

# Hitung Error
rmse = np.sqrt(mean_squared_error(test_data, predicted_mean))
print(f"Selesai! RMSE: {rmse:.2f}")

# 6. VISUALISASI LENGKAP
plt.figure(figsize=(15, 6))

# Plot Data Training (Full dari tanggal 19)
plt.plot(train_data.index, train_data, label='Data Training (Sejarah)', color='gray', alpha=0.5)

# Plot Data Asli (Test)
plt.plot(test_data.index, test_data, label='Data Asli (Test)', color='blue', linewidth=2)

# Plot Hasil Prediksi
plt.plot(predicted_mean.index, predicted_mean, label='Prediksi SARIMA', color='red', linestyle='--', linewidth=2)

# Garis pembatas Training / Test
plt.axvline(x=test_data.index[0], color='green', linestyle=':', label='Batas Prediksi')

plt.title(f'Prediksi Traffic Flow (Sensor {target_detector}) - Full History')
plt.xlabel('Tanggal')
plt.ylabel('Flow (Kendaraan/Jam)')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

from sklearn.metrics import mean_squared_error, mean_absolute_error

# ... (setelah perhitungan forecast) ...

rmse = np.sqrt(mean_squared_error(test_data, predicted_mean))
mae = mean_absolute_error(test_data, predicted_mean)

print(f"Performa Model:")
print(f"RMSE: {rmse:.2f}")
print(f"MAE : {mae:.2f}")

print(f"Rata-rata Data Asli: {test_data.mean():.2f}")

# ==========================================
# FORECASTING MASA DEPAN (3 HARI KE DEPAN)
# ==========================================

# 1. Gunakan SELURUH Data untuk Training (Agar model paling update)
# Kita tidak lagi membagi train/test, tapi pakai semuanya (ts_hourly)
print("1. Melatih ulang model dengan FULL DATA (History Lengkap)...")

full_data = ts_hourly
full_exog = exog_data

# Latih Model Final
final_model = SARIMAX(full_data,
                      exog=full_exog,
                      order=(1, 0, 1),
                      seasonal_order=(1, 1, 1, 24),
                      enforce_stationarity=False,
                      enforce_invertibility=False)

final_model_fit = final_model.fit(disp=False)

# 2. Buat Index Waktu Masa Depan
# Cek kapan data terakhir berakhir
last_date = full_data.index[-1]
print(f"   - Data terakhir Anda berakhir pada: {last_date}")

# Buat 72 jam ke depan (3 hari) mulai dari 1 jam setelah data terakhir
future_dates = pd.date_range(start=last_date + pd.Timedelta(hours=1), periods=72, freq='H')

# 3. Buat Fitur 'Weekend' untuk Masa Depan
# Kita harus memberi tahu model apakah tanggal masa depan itu Sabtu/Minggu
future_exog = pd.DataFrame(index=future_dates)
future_exog['is_weekend'] = (future_exog.index.dayofweek >= 5).astype(int)

# 4. Lakukan Prediksi
print("2. Melakukan forecasting untuk 3 hari ke depan...")
future_forecast = final_model_fit.get_forecast(steps=72, exog=future_exog)
future_mean = future_forecast.predicted_mean
future_conf_int = future_forecast.conf_int() # Interval kepercayaan

# 5. Visualisasi
plt.figure(figsize=(14, 6))

# Tampilkan sebagian data masa lalu (misal 7 hari terakhir) agar grafik nyambung
plt.plot(full_data.index[-168:], full_data[-168:], label='Data Historis (7 Hari Terakhir)', color='gray')

# Tampilkan Prediksi Masa Depan
plt.plot(future_mean.index, future_mean, label='Forecast 3 Hari Ke Depan', color='green', linewidth=2, linestyle='--')

# Tampilkan Area Ketidakpastian (Confidence Interval)
plt.fill_between(future_conf_int.index,
                 future_conf_int.iloc[:, 0],
                 future_conf_int.iloc[:, 1],
                 color='lightgreen', alpha=0.3, label='Rentang Kemungkinan')

plt.title(f'Prediksi Traffic Flow: {future_dates[0].date()} s/d {future_dates[-1].date()}')
plt.xlabel('Tanggal & Waktu')
plt.ylabel('Flow Kendaraan')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

# Tampilkan Tabel Angka Prediksi (Opsional)
print("\n--- Contoh Angka Prediksi (5 Jam Pertama) ---")
print(future_mean.head())